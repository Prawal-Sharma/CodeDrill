[
  {
    "id": 1,
    "title": "Two Sum",
    "difficulty": "easy",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists"
    ],
    "tags": ["Array", "Hash Table"],
    "testCases": [
      { "input": "[2,7,11,15]\n9", "output": "[0,1]" },
      { "input": "[3,2,4]\n6", "output": "[1,2]" },
      { "input": "[3,3]\n6", "output": "[0,1]" }
    ],
    "hints": [
      "A brute force approach would use two nested loops O(nÂ²).",
      "Can you think of a way to do this in one pass using a hash table?",
      "For each element, check if target - element exists in the hash table."
    ],
    "solution": {
      "python": "def twoSum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
      "javascript": "function twoSum(nums, target) {\n    const seen = {};\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (complement in seen) {\n            return [seen[complement], i];\n        }\n        seen[nums[i]] = i;\n    }\n    return [];\n}"
    }
  },
  {
    "id": 2,
    "title": "Reverse String",
    "difficulty": "easy",
    "description": "Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory.",
    "examples": [
      {
        "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
        "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
      },
      {
        "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
        "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]"
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is a printable ascii character"
    ],
    "tags": ["Two Pointers", "String"],
    "testCases": [
      { "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]", "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]" },
      { "input": "[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]", "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]" },
      { "input": "[\"A\"]", "output": "[\"A\"]" }
    ],
    "hints": [
      "Use two pointers, one at the beginning and one at the end.",
      "Swap characters and move pointers towards each other."
    ],
    "solution": {
      "python": "def reverseString(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1",
      "javascript": "function reverseString(s) {\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n}"
    }
  },
  {
    "id": 3,
    "title": "Valid Palindrome",
    "difficulty": "easy",
    "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Given a string s, return true if it is a palindrome, or false otherwise.",
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "\"amanaplanacanalpanama\" is a palindrome."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "\"raceacar\" is not a palindrome."
      }
    ],
    "constraints": [
      "1 <= s.length <= 2 * 10^5",
      "s consists only of printable ASCII characters"
    ],
    "tags": ["Two Pointers", "String"],
    "testCases": [
      { "input": "\"A man, a plan, a canal: Panama\"", "output": "true" },
      { "input": "\"race a car\"", "output": "false" },
      { "input": "\" \"", "output": "true" }
    ],
    "hints": [
      "Use two pointers from start and end.",
      "Skip non-alphanumeric characters.",
      "Compare characters case-insensitively."
    ],
    "solution": {
      "python": "def isPalindrome(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        if s[left].lower() != s[right].lower():\n            return False\n        left += 1\n        right -= 1\n    return True",
      "javascript": "function isPalindrome(s) {\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        while (left < right && !/[a-zA-Z0-9]/.test(s[left])) left++;\n        while (left < right && !/[a-zA-Z0-9]/.test(s[right])) right--;\n        if (s[left].toLowerCase() !== s[right].toLowerCase()) return false;\n        left++;\n        right--;\n    }\n    return true;\n}"
    }
  },
  {
    "id": 4,
    "title": "Maximum Subarray",
    "difficulty": "medium",
    "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1"
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "tags": ["Array", "Dynamic Programming", "Divide and Conquer"],
    "testCases": [
      { "input": "[-2,1,-3,4,-1,2,1,-5,4]", "output": "6" },
      { "input": "[1]", "output": "1" },
      { "input": "[5,4,-1,7,8]", "output": "23" }
    ],
    "hints": [
      "Use Kadane's algorithm.",
      "Keep track of the maximum sum ending at each position.",
      "Update the global maximum as you go."
    ],
    "solution": {
      "python": "def maxSubArray(nums):\n    max_current = max_global = nums[0]\n    for i in range(1, len(nums)):\n        max_current = max(nums[i], max_current + nums[i])\n        max_global = max(max_global, max_current)\n    return max_global",
      "javascript": "function maxSubArray(nums) {\n    let maxCurrent = maxGlobal = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        maxCurrent = Math.max(nums[i], maxCurrent + nums[i]);\n        maxGlobal = Math.max(maxGlobal, maxCurrent);\n    }\n    return maxGlobal;\n}"
    }
  },
  {
    "id": 5,
    "title": "Valid Parentheses",
    "difficulty": "easy",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets, and open brackets must be closed in the correct order.",
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true"
      },
      {
        "input": "s = \"(]\"",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only '()[]{}'"
    ],
    "tags": ["String", "Stack"],
    "testCases": [
      { "input": "\"()\"", "output": "true" },
      { "input": "\"()[]{}\"", "output": "true" },
      { "input": "\"(]\"", "output": "false" },
      { "input": "\"([)]\"", "output": "false" }
    ],
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "When you encounter a closing bracket, check if it matches the top of the stack.",
      "The string is valid if the stack is empty at the end."
    ],
    "solution": {
      "python": "def isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    return len(stack) == 0",
      "javascript": "function isValid(s) {\n    const stack = [];\n    const mapping = {')': '(', '}': '{', ']': '['};\n    for (let char of s) {\n        if (char in mapping) {\n            if (!stack.length || stack.pop() !== mapping[char]) return false;\n        } else {\n            stack.push(char);\n        }\n    }\n    return stack.length === 0;\n}"
    }
  },
  {
    "id": 6,
    "title": "Merge Two Sorted Lists",
    "difficulty": "easy",
    "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]"
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]"
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50]",
      "-100 <= Node.val <= 100",
      "Both lists are sorted in non-decreasing order"
    ],
    "tags": ["Linked List", "Recursion"],
    "testCases": [
      { "input": "[1,2,4]\n[1,3,4]", "output": "[1,1,2,3,4,4]" },
      { "input": "[]\n[]", "output": "[]" },
      { "input": "[]\n[0]", "output": "[0]" }
    ],
    "hints": [
      "Use a dummy node to simplify the logic.",
      "Compare the values of the two lists and attach the smaller one.",
      "Don't forget to handle remaining nodes."
    ],
    "solution": {
      "python": "def mergeTwoLists(list1, list2):\n    dummy = ListNode(0)\n    current = dummy\n    while list1 and list2:\n        if list1.val <= list2.val:\n            current.next = list1\n            list1 = list1.next\n        else:\n            current.next = list2\n            list2 = list2.next\n        current = current.next\n    current.next = list1 or list2\n    return dummy.next",
      "javascript": "function mergeTwoLists(list1, list2) {\n    let dummy = new ListNode(0);\n    let current = dummy;\n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    current.next = list1 || list2;\n    return dummy.next;\n}"
    }
  },
  {
    "id": 7,
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "easy",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "tags": ["Array", "Dynamic Programming"],
    "testCases": [
      { "input": "[7,1,5,3,6,4]", "output": "5" },
      { "input": "[7,6,4,3,1]", "output": "0" },
      { "input": "[2,4,1]", "output": "2" }
    ],
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate profit if selling at current price.",
      "Update maximum profit."
    ],
    "solution": {
      "python": "def maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit",
      "javascript": "function maxProfit(prices) {\n    let minPrice = Infinity;\n    let maxProfit = 0;\n    for (let price of prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}"
    }
  },
  {
    "id": 8,
    "title": "Climbing Stairs",
    "difficulty": "easy",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1. 1 step + 1 step, 2. 2 steps"
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways: 1. 1+1+1, 2. 1+2, 3. 2+1"
      }
    ],
    "constraints": [
      "1 <= n <= 45"
    ],
    "tags": ["Math", "Dynamic Programming", "Memoization"],
    "testCases": [
      { "input": "2", "output": "2" },
      { "input": "3", "output": "3" },
      { "input": "4", "output": "5" }
    ],
    "hints": [
      "This is essentially a Fibonacci sequence problem.",
      "To reach step n, you can come from step n-1 or n-2.",
      "Use dynamic programming to avoid recalculation."
    ],
    "solution": {
      "python": "def climbStairs(n):\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = 1, 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]",
      "javascript": "function climbStairs(n) {\n    if (n <= 2) return n;\n    let dp = new Array(n + 1);\n    dp[1] = 1;\n    dp[2] = 2;\n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n    return dp[n];\n}"
    }
  },
  {
    "id": 9,
    "title": "Longest Common Prefix",
    "difficulty": "easy",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\""
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the input strings."
      }
    ],
    "constraints": [
      "1 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "strs[i] consists of only lowercase English letters"
    ],
    "tags": ["String", "Trie"],
    "testCases": [
      { "input": "[\"flower\",\"flow\",\"flight\"]", "output": "\"fl\"" },
      { "input": "[\"dog\",\"racecar\",\"car\"]", "output": "\"\"" },
      { "input": "[\"a\"]", "output": "\"a\"" }
    ],
    "hints": [
      "Compare characters at each position across all strings.",
      "Stop when you find a mismatch or reach the end of any string.",
      "Consider using the first string as a reference."
    ],
    "solution": {
      "python": "def longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for j in range(1, len(strs)):\n            if i >= len(strs[j]) or strs[j][i] != char:\n                return strs[0][:i]\n    return strs[0]",
      "javascript": "function longestCommonPrefix(strs) {\n    if (!strs.length) return \"\";\n    for (let i = 0; i < strs[0].length; i++) {\n        const char = strs[0][i];\n        for (let j = 1; j < strs.length; j++) {\n            if (i >= strs[j].length || strs[j][i] !== char) {\n                return strs[0].substring(0, i);\n            }\n        }\n    }\n    return strs[0];\n}"
    }
  },
  {
    "id": 10,
    "title": "Binary Search",
    "difficulty": "easy",
    "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "examples": [
      {
        "input": "nums = [-1,0,3,5,9,12], target = 9",
        "output": "4",
        "explanation": "9 exists in nums and its index is 4"
      },
      {
        "input": "nums = [-1,0,3,5,9,12], target = 2",
        "output": "-1",
        "explanation": "2 does not exist in nums so return -1"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 < nums[i], target < 10^4",
      "All the integers in nums are unique",
      "nums is sorted in ascending order"
    ],
    "tags": ["Array", "Binary Search"],
    "testCases": [
      { "input": "[-1,0,3,5,9,12]\n9", "output": "4" },
      { "input": "[-1,0,3,5,9,12]\n2", "output": "-1" },
      { "input": "[5]\n5", "output": "0" }
    ],
    "hints": [
      "Use two pointers: left and right.",
      "Calculate the middle index and compare with target.",
      "Adjust the search range based on comparison."
    ],
    "solution": {
      "python": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
      "javascript": "function search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}"
    }
  },
  {
    "id": 11,
    "title": "Container With Most Water",
    "difficulty": "medium",
    "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The vertical lines are at positions 1 and 8, with heights 8 and 7. The area is min(8,7) * (8-1) = 49."
      },
      {
        "input": "height = [1,1]",
        "output": "1"
      }
    ],
    "constraints": [
      "n == height.length",
      "2 <= n <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "tags": ["Array", "Two Pointers", "Greedy"],
    "testCases": [
      { "input": "[1,8,6,2,5,4,8,3,7]", "output": "49" },
      { "input": "[1,1]", "output": "1" },
      { "input": "[4,3,2,1,4]", "output": "16" }
    ],
    "hints": [
      "Use two pointers starting from both ends.",
      "The area is limited by the shorter line.",
      "Move the pointer pointing to the shorter line inward."
    ],
    "solution": {
      "python": "def maxArea(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    while left < right:\n        width = right - left\n        min_height = min(height[left], height[right])\n        max_area = max(max_area, width * min_height)\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area",
      "javascript": "function maxArea(height) {\n    let left = 0, right = height.length - 1;\n    let maxArea = 0;\n    while (left < right) {\n        const width = right - left;\n        const minHeight = Math.min(height[left], height[right]);\n        maxArea = Math.max(maxArea, width * minHeight);\n        if (height[left] < height[right]) left++;\n        else right--;\n    }\n    return maxArea;\n}"
    }
  },
  {
    "id": 12,
    "title": "3Sum",
    "difficulty": "medium",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]",
        "explanation": "nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0."
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]"
      }
    ],
    "constraints": [
      "3 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "tags": ["Array", "Two Pointers", "Sorting"],
    "testCases": [
      { "input": "[-1,0,1,2,-1,-4]", "output": "[[-1,-1,2],[-1,0,1]]" },
      { "input": "[0,1,1]", "output": "[]" },
      { "input": "[0,0,0]", "output": "[[0,0,0]]" }
    ],
    "hints": [
      "Sort the array first.",
      "For each element, use two pointers to find pairs that sum to its negative.",
      "Skip duplicates to avoid duplicate triplets."
    ],
    "solution": {
      "python": "def threeSum(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return result",
      "javascript": "function threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] === nums[i-1]) continue;\n        let left = i + 1, right = nums.length - 1;\n        while (left < right) {\n            const sum = nums[i] + nums[left] + nums[right];\n            if (sum === 0) {\n                result.push([nums[i], nums[left], nums[right]]);\n                while (left < right && nums[left] === nums[left + 1]) left++;\n                while (left < right && nums[right] === nums[right - 1]) right--;\n                left++;\n                right--;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return result;\n}"
    }
  }
]