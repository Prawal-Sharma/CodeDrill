[
  {
    "id": 1,
    "title": "Two Sum",
    "difficulty": "easy",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists"
    ],
    "tags": ["Array", "Hash Table"],
    "testCases": [
      { "input": "[2,7,11,15]\n9", "output": "[0,1]" },
      { "input": "[3,2,4]\n6", "output": "[1,2]" },
      { "input": "[3,3]\n6", "output": "[0,1]" }
    ],
    "hints": [
      "A brute force approach would use two nested loops O(nÂ²).",
      "Can you think of a way to do this in one pass using a hash table?",
      "For each element, check if target - element exists in the hash table."
    ],
    "solution": {
      "python": "def twoSum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
      "javascript": "function twoSum(nums, target) {\n    const seen = {};\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (complement in seen) {\n            return [seen[complement], i];\n        }\n        seen[nums[i]] = i;\n    }\n    return [];\n}"
    }
  },
  {
    "id": 2,
    "title": "Reverse String",
    "difficulty": "easy",
    "description": "Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory.",
    "examples": [
      {
        "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
        "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
      },
      {
        "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
        "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]"
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is a printable ascii character"
    ],
    "tags": ["Two Pointers", "String"],
    "testCases": [
      { "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]", "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]" },
      { "input": "[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]", "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]" },
      { "input": "[\"A\"]", "output": "[\"A\"]" }
    ],
    "hints": [
      "Use two pointers, one at the beginning and one at the end.",
      "Swap characters and move pointers towards each other."
    ],
    "solution": {
      "python": "def reverseString(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1",
      "javascript": "function reverseString(s) {\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n}"
    }
  },
  {
    "id": 3,
    "title": "Valid Palindrome",
    "difficulty": "easy",
    "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Given a string s, return true if it is a palindrome, or false otherwise.",
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "\"amanaplanacanalpanama\" is a palindrome."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "\"raceacar\" is not a palindrome."
      }
    ],
    "constraints": [
      "1 <= s.length <= 2 * 10^5",
      "s consists only of printable ASCII characters"
    ],
    "tags": ["Two Pointers", "String"],
    "testCases": [
      { "input": "\"A man, a plan, a canal: Panama\"", "output": "true" },
      { "input": "\"race a car\"", "output": "false" },
      { "input": "\" \"", "output": "true" }
    ],
    "hints": [
      "Use two pointers from start and end.",
      "Skip non-alphanumeric characters.",
      "Compare characters case-insensitively."
    ],
    "solution": {
      "python": "def isPalindrome(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        if s[left].lower() != s[right].lower():\n            return False\n        left += 1\n        right -= 1\n    return True",
      "javascript": "function isPalindrome(s) {\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        while (left < right && !/[a-zA-Z0-9]/.test(s[left])) left++;\n        while (left < right && !/[a-zA-Z0-9]/.test(s[right])) right--;\n        if (s[left].toLowerCase() !== s[right].toLowerCase()) return false;\n        left++;\n        right--;\n    }\n    return true;\n}"
    }
  },
  {
    "id": 4,
    "title": "Maximum Subarray",
    "difficulty": "medium",
    "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1"
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "tags": ["Array", "Dynamic Programming", "Divide and Conquer"],
    "testCases": [
      { "input": "[-2,1,-3,4,-1,2,1,-5,4]", "output": "6" },
      { "input": "[1]", "output": "1" },
      { "input": "[5,4,-1,7,8]", "output": "23" }
    ],
    "hints": [
      "Use Kadane's algorithm.",
      "Keep track of the maximum sum ending at each position.",
      "Update the global maximum as you go."
    ],
    "solution": {
      "python": "def maxSubArray(nums):\n    max_current = max_global = nums[0]\n    for i in range(1, len(nums)):\n        max_current = max(nums[i], max_current + nums[i])\n        max_global = max(max_global, max_current)\n    return max_global",
      "javascript": "function maxSubArray(nums) {\n    let maxCurrent = maxGlobal = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        maxCurrent = Math.max(nums[i], maxCurrent + nums[i]);\n        maxGlobal = Math.max(maxGlobal, maxCurrent);\n    }\n    return maxGlobal;\n}"
    }
  },
  {
    "id": 5,
    "title": "Valid Parentheses",
    "difficulty": "easy",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets, and open brackets must be closed in the correct order.",
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true"
      },
      {
        "input": "s = \"(]\"",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only '()[]{}'"
    ],
    "tags": ["String", "Stack"],
    "testCases": [
      { "input": "\"()\"", "output": "true" },
      { "input": "\"()[]{}\"", "output": "true" },
      { "input": "\"(]\"", "output": "false" },
      { "input": "\"([)]\"", "output": "false" }
    ],
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "When you encounter a closing bracket, check if it matches the top of the stack.",
      "The string is valid if the stack is empty at the end."
    ],
    "solution": {
      "python": "def isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    return len(stack) == 0",
      "javascript": "function isValid(s) {\n    const stack = [];\n    const mapping = {')': '(', '}': '{', ']': '['};\n    for (let char of s) {\n        if (char in mapping) {\n            if (!stack.length || stack.pop() !== mapping[char]) return false;\n        } else {\n            stack.push(char);\n        }\n    }\n    return stack.length === 0;\n}"
    }
  },
  {
    "id": 6,
    "title": "Merge Two Sorted Lists",
    "difficulty": "easy",
    "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]"
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]"
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50]",
      "-100 <= Node.val <= 100",
      "Both lists are sorted in non-decreasing order"
    ],
    "tags": ["Linked List", "Recursion"],
    "testCases": [
      { "input": "[1,2,4]\n[1,3,4]", "output": "[1,1,2,3,4,4]" },
      { "input": "[]\n[]", "output": "[]" },
      { "input": "[]\n[0]", "output": "[0]" }
    ],
    "hints": [
      "Use a dummy node to simplify the logic.",
      "Compare the values of the two lists and attach the smaller one.",
      "Don't forget to handle remaining nodes."
    ],
    "solution": {
      "python": "def mergeTwoLists(list1, list2):\n    dummy = ListNode(0)\n    current = dummy\n    while list1 and list2:\n        if list1.val <= list2.val:\n            current.next = list1\n            list1 = list1.next\n        else:\n            current.next = list2\n            list2 = list2.next\n        current = current.next\n    current.next = list1 or list2\n    return dummy.next",
      "javascript": "function mergeTwoLists(list1, list2) {\n    let dummy = new ListNode(0);\n    let current = dummy;\n    while (list1 && list2) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    current.next = list1 || list2;\n    return dummy.next;\n}"
    }
  },
  {
    "id": 7,
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "easy",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "In this case, no transactions are done and the max profit = 0."
      }
    ],
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "tags": ["Array", "Dynamic Programming"],
    "testCases": [
      { "input": "[7,1,5,3,6,4]", "output": "5" },
      { "input": "[7,6,4,3,1]", "output": "0" },
      { "input": "[2,4,1]", "output": "2" }
    ],
    "hints": [
      "Keep track of the minimum price seen so far.",
      "Calculate profit if selling at current price.",
      "Update maximum profit."
    ],
    "solution": {
      "python": "def maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit",
      "javascript": "function maxProfit(prices) {\n    let minPrice = Infinity;\n    let maxProfit = 0;\n    for (let price of prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}"
    }
  },
  {
    "id": 8,
    "title": "Climbing Stairs",
    "difficulty": "easy",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1. 1 step + 1 step, 2. 2 steps"
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways: 1. 1+1+1, 2. 1+2, 3. 2+1"
      }
    ],
    "constraints": [
      "1 <= n <= 45"
    ],
    "tags": ["Math", "Dynamic Programming", "Memoization"],
    "testCases": [
      { "input": "2", "output": "2" },
      { "input": "3", "output": "3" },
      { "input": "4", "output": "5" }
    ],
    "hints": [
      "This is essentially a Fibonacci sequence problem.",
      "To reach step n, you can come from step n-1 or n-2.",
      "Use dynamic programming to avoid recalculation."
    ],
    "solution": {
      "python": "def climbStairs(n):\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = 1, 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]",
      "javascript": "function climbStairs(n) {\n    if (n <= 2) return n;\n    let dp = new Array(n + 1);\n    dp[1] = 1;\n    dp[2] = 2;\n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n    return dp[n];\n}"
    }
  },
  {
    "id": 9,
    "title": "Longest Common Prefix",
    "difficulty": "easy",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\""
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the input strings."
      }
    ],
    "constraints": [
      "1 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "strs[i] consists of only lowercase English letters"
    ],
    "tags": ["String", "Trie"],
    "testCases": [
      { "input": "[\"flower\",\"flow\",\"flight\"]", "output": "\"fl\"" },
      { "input": "[\"dog\",\"racecar\",\"car\"]", "output": "\"\"" },
      { "input": "[\"a\"]", "output": "\"a\"" }
    ],
    "hints": [
      "Compare characters at each position across all strings.",
      "Stop when you find a mismatch or reach the end of any string.",
      "Consider using the first string as a reference."
    ],
    "solution": {
      "python": "def longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for j in range(1, len(strs)):\n            if i >= len(strs[j]) or strs[j][i] != char:\n                return strs[0][:i]\n    return strs[0]",
      "javascript": "function longestCommonPrefix(strs) {\n    if (!strs.length) return \"\";\n    for (let i = 0; i < strs[0].length; i++) {\n        const char = strs[0][i];\n        for (let j = 1; j < strs.length; j++) {\n            if (i >= strs[j].length || strs[j][i] !== char) {\n                return strs[0].substring(0, i);\n            }\n        }\n    }\n    return strs[0];\n}"
    }
  },
  {
    "id": 10,
    "title": "Binary Search",
    "difficulty": "easy",
    "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "examples": [
      {
        "input": "nums = [-1,0,3,5,9,12], target = 9",
        "output": "4",
        "explanation": "9 exists in nums and its index is 4"
      },
      {
        "input": "nums = [-1,0,3,5,9,12], target = 2",
        "output": "-1",
        "explanation": "2 does not exist in nums so return -1"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 < nums[i], target < 10^4",
      "All the integers in nums are unique",
      "nums is sorted in ascending order"
    ],
    "tags": ["Array", "Binary Search"],
    "testCases": [
      { "input": "[-1,0,3,5,9,12]\n9", "output": "4" },
      { "input": "[-1,0,3,5,9,12]\n2", "output": "-1" },
      { "input": "[5]\n5", "output": "0" }
    ],
    "hints": [
      "Use two pointers: left and right.",
      "Calculate the middle index and compare with target.",
      "Adjust the search range based on comparison."
    ],
    "solution": {
      "python": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
      "javascript": "function search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}"
    }
  },
  {
    "id": 11,
    "title": "Container With Most Water",
    "difficulty": "medium",
    "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The vertical lines are at positions 1 and 8, with heights 8 and 7. The area is min(8,7) * (8-1) = 49."
      },
      {
        "input": "height = [1,1]",
        "output": "1"
      }
    ],
    "constraints": [
      "n == height.length",
      "2 <= n <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "tags": ["Array", "Two Pointers", "Greedy"],
    "testCases": [
      { "input": "[1,8,6,2,5,4,8,3,7]", "output": "49" },
      { "input": "[1,1]", "output": "1" },
      { "input": "[4,3,2,1,4]", "output": "16" }
    ],
    "hints": [
      "Use two pointers starting from both ends.",
      "The area is limited by the shorter line.",
      "Move the pointer pointing to the shorter line inward."
    ],
    "solution": {
      "python": "def maxArea(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    while left < right:\n        width = right - left\n        min_height = min(height[left], height[right])\n        max_area = max(max_area, width * min_height)\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area",
      "javascript": "function maxArea(height) {\n    let left = 0, right = height.length - 1;\n    let maxArea = 0;\n    while (left < right) {\n        const width = right - left;\n        const minHeight = Math.min(height[left], height[right]);\n        maxArea = Math.max(maxArea, width * minHeight);\n        if (height[left] < height[right]) left++;\n        else right--;\n    }\n    return maxArea;\n}"
    }
  },
  {
    "id": 12,
    "title": "3Sum",
    "difficulty": "medium",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.",
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]",
        "explanation": "nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0."
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]"
      }
    ],
    "constraints": [
      "3 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5"
    ],
    "tags": ["Array", "Two Pointers", "Sorting"],
    "testCases": [
      { "input": "[-1,0,1,2,-1,-4]", "output": "[[-1,-1,2],[-1,0,1]]" },
      { "input": "[0,1,1]", "output": "[]" },
      { "input": "[0,0,0]", "output": "[[0,0,0]]" }
    ],
    "hints": [
      "Sort the array first.",
      "For each element, use two pointers to find pairs that sum to its negative.",
      "Skip duplicates to avoid duplicate triplets."
    ],
    "solution": {
      "python": "def threeSum(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    return result",
      "javascript": "function threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] === nums[i-1]) continue;\n        let left = i + 1, right = nums.length - 1;\n        while (left < right) {\n            const sum = nums[i] + nums[left] + nums[right];\n            if (sum === 0) {\n                result.push([nums[i], nums[left], nums[right]]);\n                while (left < right && nums[left] === nums[left + 1]) left++;\n                while (left < right && nums[right] === nums[right - 1]) right--;\n                left++;\n                right--;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return result;\n}"
    }
  },
  {
    "id": 13,
    "title": "Remove Duplicates from Sorted Array",
    "difficulty": "easy",
    "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Return the number of unique elements in nums.",
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2",
        "explanation": "Your function should return k = 2, with the first two elements of nums being 1 and 2."
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order"
    ],
    "tags": ["Array", "Two Pointers"],
    "testCases": [
      { "input": "[1,1,2]", "output": "2" },
      { "input": "[0,0,1,1,1,2,2,3,3,4]", "output": "5" },
      { "input": "[1,2,3]", "output": "3" }
    ],
    "hints": [
      "Use two pointers technique.",
      "Keep one pointer for the unique elements and another for scanning."
    ],
    "solution": {
      "python": "def removeDuplicates(nums):\n    if not nums:\n        return 0\n    \n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    \n    return i + 1",
      "javascript": "function removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    \n    let i = 0;\n    for (let j = 1; j < nums.length; j++) {\n        if (nums[j] !== nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    \n    return i + 1;\n}"
    }
  },
  {
    "id": 14,
    "title": "Plus One",
    "difficulty": "easy",
    "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading zeros. Increment the large integer by one and return the resulting array of digits.",
    "examples": [
      {
        "input": "digits = [1,2,3]",
        "output": "[1,2,4]",
        "explanation": "The array represents the integer 123. Incrementing by one gives 123 + 1 = 124."
      },
      {
        "input": "digits = [9]",
        "output": "[1,0]",
        "explanation": "The array represents the integer 9. Incrementing by one gives 9 + 1 = 10."
      }
    ],
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not contain any leading zeros except for the number 0 itself"
    ],
    "tags": ["Array", "Math"],
    "testCases": [
      { "input": "[1,2,3]", "output": "[1,2,4]" },
      { "input": "[9]", "output": "[1,0]" },
      { "input": "[9,9,9]", "output": "[1,0,0,0]" }
    ],
    "hints": [
      "Handle the carry from right to left.",
      "Consider the case where all digits are 9."
    ],
    "solution": {
      "python": "def plusOne(digits):\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    \n    return [1] + digits",
      "javascript": "function plusOne(digits) {\n    for (let i = digits.length - 1; i >= 0; i--) {\n        if (digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n    \n    return [1, ...digits];\n}"
    }
  },
  {
    "id": 15,
    "title": "Rotate Array",
    "difficulty": "medium",
    "description": "Given an array, rotate the array to the right by k steps, where k is non-negative.",
    "examples": [
      {
        "input": "nums = [1,2,3,4,5,6,7], k = 3",
        "output": "[5,6,7,1,2,3,4]",
        "explanation": "Rotate to the right by 3 steps: [7,1,2,3,4,5,6] -> [6,7,1,2,3,4,5] -> [5,6,7,1,2,3,4]"
      },
      {
        "input": "nums = [-1,-100,3,99], k = 2",
        "output": "[3,99,-1,-100]"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-2^31 <= nums[i] <= 2^31 - 1",
      "0 <= k <= 10^5"
    ],
    "tags": ["Array", "Math", "Two Pointers"],
    "testCases": [
      { "input": "[1,2,3,4,5,6,7]\n3", "output": "[5,6,7,1,2,3,4]" },
      { "input": "[-1,-100,3,99]\n2", "output": "[3,99,-1,-100]" },
      { "input": "[1,2]\n1", "output": "[2,1]" }
    ],
    "hints": [
      "Try to come up with as many solutions as possible.",
      "Use reverse to achieve O(1) space complexity.",
      "Consider k might be larger than array length."
    ],
    "solution": {
      "python": "def rotate(nums, k):\n    n = len(nums)\n    k = k % n\n    \n    def reverse(start, end):\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1\n    \n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)",
      "javascript": "function rotate(nums, k) {\n    const n = nums.length;\n    k = k % n;\n    \n    function reverse(start, end) {\n        while (start < end) {\n            [nums[start], nums[end]] = [nums[end], nums[start]];\n            start++;\n            end--;\n        }\n    }\n    \n    reverse(0, n - 1);\n    reverse(0, k - 1);\n    reverse(k, n - 1);\n}"
    }
  },
  {
    "id": 16,
    "title": "Single Number",
    "difficulty": "easy",
    "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.",
    "examples": [
      {
        "input": "nums = [2,2,1]",
        "output": "1"
      },
      {
        "input": "nums = [4,1,2,1,2]",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-3 * 10^4 <= nums[i] <= 3 * 10^4",
      "Each element in the array appears twice except for one element which appears only once"
    ],
    "tags": ["Array", "Bit Manipulation"],
    "testCases": [
      { "input": "[2,2,1]", "output": "1" },
      { "input": "[4,1,2,1,2]", "output": "4" },
      { "input": "[1]", "output": "1" }
    ],
    "hints": [
      "Think about XOR operation.",
      "XOR of two identical numbers is 0.",
      "XOR of any number with 0 is the number itself."
    ],
    "solution": {
      "python": "def singleNumber(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result",
      "javascript": "function singleNumber(nums) {\n    let result = 0;\n    for (let num of nums) {\n        result ^= num;\n    }\n    return result;\n}"
    }
  },
  {
    "id": 17,
    "title": "Intersection of Two Arrays II",
    "difficulty": "easy",
    "description": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.",
    "examples": [
      {
        "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
        "output": "[2,2]"
      },
      {
        "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
        "output": "[4,9]",
        "explanation": "[9,4] is also accepted."
      }
    ],
    "constraints": [
      "1 <= nums1.length, nums2.length <= 1000",
      "0 <= nums1[i], nums2[i] <= 1000"
    ],
    "tags": ["Array", "Hash Table", "Two Pointers", "Binary Search", "Sorting"],
    "testCases": [
      { "input": "[1,2,2,1]\n[2,2]", "output": "[2,2]" },
      { "input": "[4,9,5]\n[9,4,9,8,4]", "output": "[4,9]" },
      { "input": "[1,2]\n[1,1]", "output": "[1]" }
    ],
    "hints": [
      "Use a hash map to count elements.",
      "Iterate through the second array and check counts."
    ],
    "solution": {
      "python": "def intersect(nums1, nums2):\n    from collections import Counter\n    count1 = Counter(nums1)\n    result = []\n    \n    for num in nums2:\n        if count1[num] > 0:\n            result.append(num)\n            count1[num] -= 1\n    \n    return result",
      "javascript": "function intersect(nums1, nums2) {\n    const count = {};\n    const result = [];\n    \n    for (let num of nums1) {\n        count[num] = (count[num] || 0) + 1;\n    }\n    \n    for (let num of nums2) {\n        if (count[num] > 0) {\n            result.push(num);\n            count[num]--;\n        }\n    }\n    \n    return result;\n}"
    }
  },
  {
    "id": 18,
    "title": "Valid Anagram",
    "difficulty": "easy",
    "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "examples": [
      {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true"
      },
      {
        "input": "s = \"rat\", t = \"car\"",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= s.length, t.length <= 5 * 10^4",
      "s and t consist of lowercase English letters"
    ],
    "tags": ["Hash Table", "String", "Sorting"],
    "testCases": [
      { "input": "\"anagram\"\n\"nagaram\"", "output": "true" },
      { "input": "\"rat\"\n\"car\"", "output": "false" },
      { "input": "\"a\"\n\"ab\"", "output": "false" }
    ],
    "hints": [
      "Use character frequency counting.",
      "Sorting both strings is another approach."
    ],
    "solution": {
      "python": "def isAnagram(s, t):\n    if len(s) != len(t):\n        return False\n    \n    from collections import Counter\n    return Counter(s) == Counter(t)",
      "javascript": "function isAnagram(s, t) {\n    if (s.length !== t.length) return false;\n    \n    const count = {};\n    for (let char of s) {\n        count[char] = (count[char] || 0) + 1;\n    }\n    \n    for (let char of t) {\n        if (!count[char]) return false;\n        count[char]--;\n    }\n    \n    return true;\n}"
    }
  },
  {
    "id": 19,
    "title": "Group Anagrams",
    "difficulty": "medium",
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
      }
    ],
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100"
    ],
    "tags": ["Array", "Hash Table", "String", "Sorting"],
    "testCases": [
      { "input": "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]", "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]" },
      { "input": "[\"\"]", "output": "[[\"\"]]" },
      { "input": "[\"a\"]", "output": "[[\"a\"]]" }
    ],
    "hints": [
      "Use sorted string as key for grouping.",
      "Hash map with sorted strings as keys."
    ],
    "solution": {
      "python": "def groupAnagrams(strs):\n    from collections import defaultdict\n    groups = defaultdict(list)\n    \n    for s in strs:\n        key = ''.join(sorted(s))\n        groups[key].append(s)\n    \n    return list(groups.values())",
      "javascript": "function groupAnagrams(strs) {\n    const groups = {};\n    \n    for (let str of strs) {\n        const key = str.split('').sort().join('');\n        if (!groups[key]) groups[key] = [];\n        groups[key].push(str);\n    }\n    \n    return Object.values(groups);\n}"
    }
  },
  {
    "id": 20,
    "title": "Contains Duplicate",
    "difficulty": "easy",
    "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "true"
      },
      {
        "input": "nums = [1,2,3,4]",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "tags": ["Array", "Hash Table", "Sorting"],
    "testCases": [
      { "input": "[1,2,3,1]", "output": "true" },
      { "input": "[1,2,3,4]", "output": "false" },
      { "input": "[1,1,1,3,3,4,3,2,4,2]", "output": "true" }
    ],
    "hints": [
      "Use a hash set to track seen elements.",
      "Sorting is another approach but less efficient."
    ],
    "solution": {
      "python": "def containsDuplicate(nums):\n    return len(nums) != len(set(nums))",
      "javascript": "function containsDuplicate(nums) {\n    const seen = new Set();\n    for (let num of nums) {\n        if (seen.has(num)) return true;\n        seen.add(num);\n    }\n    return false;\n}"
    }
  },
  {
    "id": 21,
    "title": "Product of Array Except Self",
    "difficulty": "medium",
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. You must write an algorithm that runs in O(n) time and without using the division operation.",
    "examples": [
      {
        "input": "nums = [1,2,3,4]",
        "output": "[24,12,8,6]"
      },
      {
        "input": "nums = [-1,1,0,-3,3]",
        "output": "[0,0,9,0,0]"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30"
    ],
    "tags": ["Array", "Prefix Sum"],
    "testCases": [
      { "input": "[1,2,3,4]", "output": "[24,12,8,6]" },
      { "input": "[-1,1,0,-3,3]", "output": "[0,0,9,0,0]" },
      { "input": "[2,3,4,5]", "output": "[60,40,30,24]" }
    ],
    "hints": [
      "Think about prefix and suffix products.",
      "Use two passes: left to right, then right to left."
    ],
    "solution": {
      "python": "def productExceptSelf(nums):\n    n = len(nums)\n    result = [1] * n\n    \n    # Left products\n    for i in range(1, n):\n        result[i] = result[i-1] * nums[i-1]\n    \n    # Right products\n    right = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= right\n        right *= nums[i]\n    \n    return result",
      "javascript": "function productExceptSelf(nums) {\n    const n = nums.length;\n    const result = new Array(n).fill(1);\n    \n    // Left products\n    for (let i = 1; i < n; i++) {\n        result[i] = result[i-1] * nums[i-1];\n    }\n    \n    // Right products\n    let right = 1;\n    for (let i = n-1; i >= 0; i--) {\n        result[i] *= right;\n        right *= nums[i];\n    }\n    \n    return result;\n}"
    }
  },
  {
    "id": 22,
    "title": "Maximum Depth of Binary Tree",
    "difficulty": "easy",
    "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3"
      },
      {
        "input": "root = [1,null,2]",
        "output": "2"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4]",
      "-100 <= Node.val <= 100"
    ],
    "tags": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
    "testCases": [
      { "input": "[3,9,20,null,null,15,7]", "output": "3" },
      { "input": "[1,null,2]", "output": "2" },
      { "input": "[]", "output": "0" }
    ],
    "hints": [
      "Use recursion to traverse the tree.",
      "The depth is 1 + maximum of left and right subtree depths."
    ],
    "solution": {
      "python": "def maxDepth(root):\n    if not root:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))",
      "javascript": "function maxDepth(root) {\n    if (!root) return 0;\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}"
    }
  },
  {
    "id": 23,
    "title": "Same Tree",
    "difficulty": "easy",
    "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
    "examples": [
      {
        "input": "p = [1,2,3], q = [1,2,3]",
        "output": "true"
      },
      {
        "input": "p = [1,2], q = [1,null,2]",
        "output": "false"
      }
    ],
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100]",
      "-10^4 <= Node.val <= 10^4"
    ],
    "tags": ["Tree", "Depth-First Search", "Binary Tree"],
    "testCases": [
      { "input": "[1,2,3]\n[1,2,3]", "output": "true" },
      { "input": "[1,2]\n[1,null,2]", "output": "false" },
      { "input": "[1,2,1]\n[1,1,2]", "output": "false" }
    ],
    "hints": [
      "Use recursion to compare trees.",
      "Both trees are same if roots are same and subtrees are same."
    ],
    "solution": {
      "python": "def isSameTree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    return (p.val == q.val and \n            isSameTree(p.left, q.left) and \n            isSameTree(p.right, q.right))",
      "javascript": "function isSameTree(p, q) {\n    if (!p && !q) return true;\n    if (!p || !q) return false;\n    return p.val === q.val && \n           isSameTree(p.left, q.left) && \n           isSameTree(p.right, q.right);\n}"
    }
  },
  {
    "id": 24,
    "title": "Invert Binary Tree",
    "difficulty": "easy",
    "description": "Given the root of a binary tree, invert the tree, and return its root. Inverting a binary tree means swapping the left and right children of all nodes.",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1]"
      },
      {
        "input": "root = [2,1,3]",
        "output": "[2,3,1]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100]",
      "-100 <= Node.val <= 100"
    ],
    "tags": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
    "testCases": [
      { "input": "[4,2,7,1,3,6,9]", "output": "[4,7,2,9,6,3,1]" },
      { "input": "[2,1,3]", "output": "[2,3,1]" },
      { "input": "[]", "output": "[]" }
    ],
    "hints": [
      "Swap left and right children of each node.",
      "Use recursion to invert subtrees."
    ],
    "solution": {
      "python": "def invertTree(root):\n    if not root:\n        return None\n    \n    # Swap children\n    root.left, root.right = root.right, root.left\n    \n    # Recursively invert subtrees\n    invertTree(root.left)\n    invertTree(root.right)\n    \n    return root",
      "javascript": "function invertTree(root) {\n    if (!root) return null;\n    \n    // Swap children\n    [root.left, root.right] = [root.right, root.left];\n    \n    // Recursively invert subtrees\n    invertTree(root.left);\n    invertTree(root.right);\n    \n    return root;\n}"
    }
  },
  {
    "id": 25,
    "title": "House Robber",
    "difficulty": "medium",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "4",
        "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4."
      },
      {
        "input": "nums = [2,7,9,3,1]",
        "output": "12",
        "explanation": "Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "tags": ["Array", "Dynamic Programming"],
    "testCases": [
      { "input": "[1,2,3,1]", "output": "4" },
      { "input": "[2,7,9,3,1]", "output": "12" },
      { "input": "[2,1,1,2]", "output": "4" }
    ],
    "hints": [
      "Use dynamic programming.",
      "For each house, decide whether to rob it or not.",
      "dp[i] = max(dp[i-1], dp[i-2] + nums[i])"
    ],
    "solution": {
      "python": "def rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    prev2, prev1 = nums[0], max(nums[0], nums[1])\n    \n    for i in range(2, len(nums)):\n        current = max(prev1, prev2 + nums[i])\n        prev2, prev1 = prev1, current\n    \n    return prev1",
      "javascript": "function rob(nums) {\n    if (nums.length === 0) return 0;\n    if (nums.length === 1) return nums[0];\n    \n    let prev2 = nums[0];\n    let prev1 = Math.max(nums[0], nums[1]);\n    \n    for (let i = 2; i < nums.length; i++) {\n        const current = Math.max(prev1, prev2 + nums[i]);\n        prev2 = prev1;\n        prev1 = current;\n    }\n    \n    return prev1;\n}"
    }
  },
  {
    "id": 26,
    "title": "Coin Change",
    "difficulty": "medium",
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
    "examples": [
      {
        "input": "coins = [1,3,4], amount = 6",
        "output": "2",
        "explanation": "The minimum number of coins is 2 (3 + 3)."
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1"
      }
    ],
    "constraints": [
      "1 <= coins.length <= 12",
      "1 <= coins[i] <= 2^31 - 1",
      "0 <= amount <= 10^4"
    ],
    "tags": ["Array", "Dynamic Programming", "Breadth-First Search"],
    "testCases": [
      { "input": "[1,3,4]\n6", "output": "2" },
      { "input": "[2]\n3", "output": "-1" },
      { "input": "[1]\n0", "output": "0" }
    ],
    "hints": [
      "Use dynamic programming.",
      "dp[i] = minimum coins to make amount i",
      "For each coin, update all amounts that can be made with it."
    ],
    "solution": {
      "python": "def coinChange(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1",
      "javascript": "function coinChange(coins, amount) {\n    const dp = new Array(amount + 1).fill(Infinity);\n    dp[0] = 0;\n    \n    for (let coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n    }\n    \n    return dp[amount] === Infinity ? -1 : dp[amount];\n}"
    }
  },
  {
    "id": 27,
    "title": "Number of Islands",
    "difficulty": "medium",
    "description": "Given an m x n 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.",
    "examples": [
      {
        "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
        "output": "1"
      },
      {
        "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
        "output": "3"
      }
    ],
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300"
    ],
    "tags": ["Array", "Depth-First Search", "Breadth-First Search", "Union Find", "Matrix"],
    "testCases": [
      { "input": "[[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]", "output": "1" },
      { "input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]", "output": "3" },
      { "input": "[[\"1\"]]", "output": "1" }
    ],
    "hints": [
      "Use DFS to mark connected land cells.",
      "For each unvisited '1', start a DFS and increment island count."
    ],
    "solution": {
      "python": "def numIslands(grid):\n    if not grid:\n        return 0\n    \n    def dfs(i, j):\n        if (i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or \n            grid[i][j] == '0'):\n            return\n        \n        grid[i][j] = '0'  # Mark as visited\n        \n        # Explore all 4 directions\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n    \n    return count",
      "javascript": "function numIslands(grid) {\n    if (!grid || grid.length === 0) return 0;\n    \n    function dfs(i, j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || \n            grid[i][j] === '0') {\n            return;\n        }\n        \n        grid[i][j] = '0'; // Mark as visited\n        \n        // Explore all 4 directions\n        dfs(i + 1, j);\n        dfs(i - 1, j);\n        dfs(i, j + 1);\n        dfs(i, j - 1);\n    }\n    \n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] === '1') {\n                count++;\n                dfs(i, j);\n            }\n        }\n    }\n    \n    return count;\n}"
    }
  }
]